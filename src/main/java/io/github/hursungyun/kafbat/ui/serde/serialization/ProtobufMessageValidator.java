package io.github.hursungyun.kafbat.ui.serde.serialization;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.protobuf.Descriptors;
import com.google.protobuf.DynamicMessage;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Validator for protobuf messages and JSON input
 *
 * <h2>Synthetic vs Real OneOf Fields</h2>
 *
 * <p>This validator distinguishes between two types of oneOf groups:
 *
 * <ul>
 *   <li><b>Synthetic oneOf</b>: Auto-generated by the protobuf compiler for proto3 optional fields
 *       (e.g., {@code optional string description = 9;} creates a synthetic oneOf named {@code
 *       _description}). These are implementation details for presence tracking and should NOT be
 *       validated.
 *   <li><b>Real oneOf</b>: Explicitly declared business logic constraints (e.g., {@code oneof
 *       notification_type { email, sms, push }}). These require exactly one variant to be set and
 *       MUST be validated.
 * </ul>
 *
 * <p>Use {@link com.google.protobuf.Descriptors.OneofDescriptor#isSynthetic()} to distinguish:
 *
 * <ul>
 *   <li>{@code isSynthetic() = true} → Skip validation (optional by definition)
 *   <li>{@code isSynthetic() = false} → Validate (ensure one variant is set)
 * </ul>
 *
 * @see <a
 *     href="https://github.com/protocolbuffers/protobuf/blob/main/docs/implementing_proto3_presence.md">Proto3
 *     Presence Documentation</a>
 */
public class ProtobufMessageValidator {

    private final ObjectMapper objectMapper;

    public ProtobufMessageValidator() {
        this.objectMapper = new ObjectMapper();
    }

    /**
     * Validate a DynamicMessage for oneOf fields only
     *
     * <p>This method validates only oneOf constraints using the protobuf DynamicMessage API. It
     * should be called AFTER JSON-based field presence validation.
     *
     * @param message the DynamicMessage to validate
     * @throws IllegalArgumentException if oneOf validation fails
     */
    public void validateOneOfFields(DynamicMessage message) {
        Descriptors.Descriptor descriptor = message.getDescriptorForType();

        // Validate oneOf fields - ensure at least one variant is set
        for (Descriptors.OneofDescriptor oneOf : descriptor.getOneofs()) {
            // Skip synthetic oneOf groups (proto3 optional fields) - see class documentation
            if (oneOf.isSynthetic()) {
                continue;
            }

            Descriptors.FieldDescriptor activeField = message.getOneofFieldDescriptor(oneOf);

            if (activeField == null) {
                // No field is set in this oneOf - collect variant names for error message
                List<String> variantNames = new ArrayList<>();
                for (Descriptors.FieldDescriptor field : oneOf.getFields()) {
                    variantNames.add(field.getJsonName());
                }
                throw new IllegalArgumentException(
                        "Missing required oneOf '"
                                + oneOf.getName()
                                + "' in message type '"
                                + descriptor.getFullName()
                                + "'. At least one of: "
                                + String.join(", ", variantNames));
            }
        }

        // Recursively validate nested messages
        for (Descriptors.FieldDescriptor field : descriptor.getFields()) {
            if (field.getJavaType() == Descriptors.FieldDescriptor.JavaType.MESSAGE) {
                if (field.isRepeated()) {
                    // Validate each element in repeated message field
                    @SuppressWarnings("unchecked")
                    List<DynamicMessage> messageList =
                            (List<DynamicMessage>) message.getField(field);
                    for (DynamicMessage nestedMessage : messageList) {
                        validateOneOfFields(nestedMessage);
                    }
                } else if (message.hasField(field)) {
                    // Validate singular nested message (only if present)
                    validateOneOfFields((DynamicMessage) message.getField(field));
                }
            }
        }
    }

    /** Validate required fields for proto2 messages - DEPRECATED, use validateMessage instead */
    @Deprecated
    public void validateRequiredFields(
            DynamicMessage message, Descriptors.Descriptor messageDescriptor) {
        for (Descriptors.FieldDescriptor field : messageDescriptor.getFields()) {
            if (field.isRequired() && !message.hasField(field)) {
                throw new IllegalArgumentException(
                        "Required field '"
                                + field.getName()
                                + "' is missing in message type '"
                                + messageDescriptor.getFullName()
                                + "'");
            }
        }
    }

    /**
     * For proto3: validate that JSON contains expected keys (even if values are null) This helps
     * ensure that the client is aware of all the fields they should be setting
     */
    public void validateJsonKeysForProto3(
            String jsonInput, Descriptors.Descriptor messageDescriptor) throws Exception {
        JsonNode jsonNode = objectMapper.readTree(jsonInput);

        // Check for explicitly provided keys with null values
        for (Descriptors.FieldDescriptor field : messageDescriptor.getFields()) {
            String jsonFieldName = getJsonFieldName(field);

            // In proto3, if a key is explicitly present in JSON (even with null value),
            // we want to track this for validation purposes
            if (jsonNode.has(jsonFieldName)) {
                JsonNode fieldValue = jsonNode.get(jsonFieldName);
                // This is informational - we're just checking that the key exists
                // The actual validation of null values will be handled by the JsonFormat.Parser

                // For enum fields, validate the enum value if it's not null
                if (!fieldValue.isNull()
                        && field.getType() == Descriptors.FieldDescriptor.Type.ENUM) {
                    validateEnumValue(field, fieldValue);
                }
            }
        }
    }

    /**
     * Validate that all required JSON keys are present in the input Throws detailed error message
     * listing missing keys
     */
    public void validateRequiredKeysPresent(
            String jsonInput, Descriptors.Descriptor messageDescriptor, List<String> requiredFields)
            throws Exception {
        if (requiredFields == null || requiredFields.isEmpty()) {
            return;
        }

        JsonNode jsonNode = objectMapper.readTree(jsonInput);
        List<String> missingKeys = new ArrayList<>();

        for (String requiredFieldName : requiredFields) {
            // Find the field descriptor by name
            Descriptors.FieldDescriptor field =
                    findFieldByName(messageDescriptor, requiredFieldName);
            if (field != null) {
                String jsonFieldName = getJsonFieldName(field);
                if (!jsonNode.has(jsonFieldName)) {
                    missingKeys.add(jsonFieldName + " (" + field.getName() + ")");
                }
            } else {
                // Field name not found in descriptor - add to missing list
                missingKeys.add(requiredFieldName + " (field not found in schema)");
            }
        }

        if (!missingKeys.isEmpty()) {
            throw new IllegalArgumentException(
                    "Missing required keys in JSON for message type '"
                            + messageDescriptor.getFullName()
                            + "': "
                            + String.join(", ", missingKeys)
                            + ". Expected keys: "
                            + requiredFields.stream().collect(Collectors.joining(", ")));
        }
    }

    /** Validate that specific fields are present in JSON (useful for validation rules) */
    public void validateFieldsPresent(
            String jsonInput, Descriptors.Descriptor messageDescriptor, String... fieldNames)
            throws Exception {
        JsonNode jsonNode = objectMapper.readTree(jsonInput);
        List<String> missingKeys = new ArrayList<>();

        for (String fieldName : fieldNames) {
            Descriptors.FieldDescriptor field = findFieldByName(messageDescriptor, fieldName);
            if (field != null) {
                String jsonFieldName = getJsonFieldName(field);
                if (!jsonNode.has(jsonFieldName)) {
                    missingKeys.add(jsonFieldName + " (" + field.getName() + ")");
                }
            } else {
                missingKeys.add(fieldName + " (field not found in schema)");
            }
        }

        if (!missingKeys.isEmpty()) {
            throw new IllegalArgumentException(
                    "Missing required keys in JSON for message type '"
                            + messageDescriptor.getFullName()
                            + "': "
                            + String.join(", ", missingKeys));
        }
    }

    /** Find field descriptor by name (tries both original name and camelCase) */
    private Descriptors.FieldDescriptor findFieldByName(
            Descriptors.Descriptor messageDescriptor, String fieldName) {
        // Try exact match first
        for (Descriptors.FieldDescriptor field : messageDescriptor.getFields()) {
            if (field.getName().equals(fieldName) || getJsonFieldName(field).equals(fieldName)) {
                return field;
            }
        }
        return null;
    }

    /** Get the JSON field name for a protobuf field (camelCase only) */
    private String getJsonFieldName(Descriptors.FieldDescriptor field) {
        // Use the standard JSON name (which is camelCase by default in protobuf)
        String jsonName = field.getJsonName();
        if (jsonName != null && !jsonName.isEmpty()) {
            return jsonName;
        }

        // Fallback to field name as-is (assuming it's already camelCase)
        return field.getName();
    }

    /** Validate enum value in JSON */
    private void validateEnumValue(Descriptors.FieldDescriptor field, JsonNode fieldValue) {
        if (fieldValue.isTextual()) {
            String enumValueName = fieldValue.asText();
            Descriptors.EnumValueDescriptor enumValue =
                    field.getEnumType().findValueByName(enumValueName);
            if (enumValue == null) {
                throw new IllegalArgumentException(
                        "Invalid enum value '"
                                + enumValueName
                                + "' for field '"
                                + field.getName()
                                + "' in enum type '"
                                + field.getEnumType().getFullName()
                                + "'");
            }
        } else if (fieldValue.isNumber()) {
            int enumValueNumber = fieldValue.asInt();
            Descriptors.EnumValueDescriptor enumValue =
                    field.getEnumType().findValueByNumber(enumValueNumber);
            if (enumValue == null) {
                throw new IllegalArgumentException(
                        "Invalid enum number '"
                                + enumValueNumber
                                + "' for field '"
                                + field.getName()
                                + "' in enum type '"
                                + field.getEnumType().getFullName()
                                + "'");
            }
        }
    }

    /**
     * Validate that ALL fields in the protobuf schema are explicitly present in JSON This enforces
     * strict validation where missing fields cause serialization to fail
     *
     * <p>For oneOf fields: only requires that at least ONE variant is present (can be null or have
     * a value). Other variants in the same oneOf are optional and don't need to be present.
     */
    public void validateAllFieldsPresent(String jsonInput, Descriptors.Descriptor messageDescriptor)
            throws Exception {
        JsonNode jsonNode = objectMapper.readTree(jsonInput);
        List<String> missingFields = new ArrayList<>();

        // Build a set of fields that are part of a oneOf and should be skipped if another variant
        // is present
        List<Descriptors.FieldDescriptor> fieldsToSkip = new ArrayList<>();

        // Check each oneOf - if at least one variant is present, skip validation for other variants
        for (Descriptors.OneofDescriptor oneOf : messageDescriptor.getOneofs()) {
            // Skip synthetic oneOf groups (proto3 optional fields) - see class documentation
            if (oneOf.isSynthetic()) {
                // Still need to skip validation for the optional field itself
                // since it's part of the synthetic oneOf
                fieldsToSkip.addAll(oneOf.getFields());
                continue;
            }

            boolean hasAtLeastOneVariant = false;
            Descriptors.FieldDescriptor presentField = null;

            for (Descriptors.FieldDescriptor field : oneOf.getFields()) {
                String jsonFieldName = getJsonFieldName(field);
                if (jsonNode.has(jsonFieldName)) {
                    hasAtLeastOneVariant = true;
                    presentField = field;
                    break;
                }
            }

            if (hasAtLeastOneVariant) {
                // One variant is present, so skip validation for all other variants in this oneOf
                for (Descriptors.FieldDescriptor field : oneOf.getFields()) {
                    if (field != presentField) {
                        fieldsToSkip.add(field);
                    }
                }
            } else {
                // No variant is present - require at least one to be present
                List<String> variantNames = new ArrayList<>();
                for (Descriptors.FieldDescriptor field : oneOf.getFields()) {
                    variantNames.add(getJsonFieldName(field));
                }
                missingFields.add(
                        "oneOf "
                                + oneOf.getName()
                                + " (at least one of: "
                                + String.join(", ", variantNames)
                                + ")");
                // Skip checking individual fields since we reported the oneOf as missing
                fieldsToSkip.addAll(oneOf.getFields());
            }
        }

        // Check all fields except those in fieldsToSkip
        for (Descriptors.FieldDescriptor field : messageDescriptor.getFields()) {
            if (fieldsToSkip.contains(field)) {
                continue;
            }

            String jsonFieldName = getJsonFieldName(field);
            if (!jsonNode.has(jsonFieldName)) {
                missingFields.add(
                        jsonFieldName + " (" + field.getType().name().toLowerCase() + ")");
            }
        }

        if (!missingFields.isEmpty()) {
            throw new IllegalArgumentException(
                    "All fields must be explicitly provided in JSON for message type '"
                            + messageDescriptor.getFullName()
                            + "'. "
                            + "Missing fields: "
                            + String.join(", ", missingFields)
                            + ". Provide all fields with appropriate values (use null for optional"
                            + " fields).");
        }
    }
}
